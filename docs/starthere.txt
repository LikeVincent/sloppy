DEVELOPER NOTES

$Id$

In addition to the Java Doc this short note should help
you get into the code.

Although Sloppy now looks like a desktop application,
it was first developed as a server application: it would 
listen for HTTP requests on a particular port for any 
number of users.  

Sloppy still works this way.  If you're running Sloppy
on your machine, anyone else on the network can 
connect to your instance of Sloppy and see a site
slowed down.  However, this doesn't really make much sense
anymore, and it's not the direction the code is going in.

To understand the code, start with SloppyServer.
This class starts listening on a port and hands off
each request to an instance of SlowProxyThread.

SlowProxyThread is the go-between for reading from
the web browser, calling the web server, reading
from the web server and passing the data back
to the web client.

This is where the bandwidth limited happens.  
Just before writing data back to the web browser,
SlowProxyThread calculates the pause required to simulate
a particular bandwidth setting.  I.e., the thinking is "I've
sent so-many bytes in the last so-many seconds; if I was
a 56k modem, that would have really taken X seconds, so I need
to pause before I send that data on."

The class Bottleneck implements this thinking.  To keep
track of the bandwidth usage, there's a class called Usage.
Note that Bandwidth keeps a hash of Usage objects -- one
per client, because (remember) Sloppy is a multi-user
server behind the scenes.

[BTW, previous versions of Sloppy just connected
the output from the browser to the input of the 
web server, and the output from the server to the
input of the web browser -- as two separate threads.
This was sort of elegant,  but because it used 
java.net.Socket it didn't work with proxies.  
As of version 1.1 Sloppy uses URLConnection.]

The GUI side of Sloppy is set up by SloppyGUI.  This just
reads and writes the Configuration object -- the Configuration
being the port to listen on, the Bandwidth to simulate... etc.

Sloppy.java is the main class that kicks all this off.  It
decides if the user wants to start up with or without
a GUI and reads the Configuration (either taking
the defaults, reading a properties file from disk, or reading
the properties file from a Java Web Start "muffin").

Sloppy produces a number of messages (debugging, errors). When
running with a GUI, these messages need to go to pop-up
windows; when running without a GUI, the messages go to
the console.  The interface UserInterface.java defines
the types of messages that Sloppy can produce.  SloppyGUI
implements the UserInterface where messages are sent to 
pop-up windows.  ConsoleLogger implements the UserInterface
where messages are sent to the console.  You can ask
the Configuration object to give you the current UserInterface
so your messages will go to the right place.  In this respect,
the Configuration objects acts as the meeting point between
the GUI and the SloppyServer object.

The final class is ReleaseInfo, which is a singleton to tell
you what version of Sloppy is running and what the copyright
notice is.  The build number is held in build.properties, and
I use an ANT script to increment the build number after
each build of the system.


JUNIT

There are a small number of JUnit tests with Sloppy.
See http://www.junit.org for information about JUnit.


COMPILATION

To compile Sloppy you will need junit.jar (from
junit.org, version 3.7) and jnlp.jar (from
the Web Start install, or from your JDK in jre/javaws/javaws.jar
which for the Mac is /Applications/Utilities/Java/Java\ Web\ Start.app/Contents/MacOS/javaws.jar 
).


